//
//  PlayerEventProducer.swift
//  AudioPlayer
//
//  Created by Kevin DELANNOY on 08/03/16.
//  Copyright Â© 2016 Kevin Delannoy. All rights reserved.
//

import AVFoundation

// MARK: - AVPlayer+KVO

private extension AVPlayer {
    
    //swiftlint:disable variable_name
    /// The list of properties that is observed through KVO.
    static var ap_KVOProperties: [String] {
        return [
            "currentItem.playbackBufferEmpty",
            "currentItem.playbackLikelyToKeepUp",
            "currentItem.duration",
            "currentItem.status",
            "status",
            "currentItem.loadedTimeRanges",
            "currentItem.timedMetadata"]
    }
}

// MARK: - Selector+PlayerEventProducer

private extension Selector {
    
    /// The selector to call when the audio session is interrupted.
    static let audioSessionInterrupted =
        #selector(PlayerEventProducer.audioSessionGotInterrupted(note:))
    
    /// The selector to call when the audio session route changes.
    static let audioRouteChanged = #selector(PlayerEventProducer.audioSessionRouteChanged(note:))
    
    /// The selector to call when the audio session get messed up.
    static let audioSessionMessedUp = #selector(PlayerEventProducer.audioSessionMessedUp(note:))
    
    /// The selector to call when an audio item ends playing.
    static let itemDidEnd = #selector(PlayerEventProducer.playerItemDidEnd(note:))
}

// MARK: - PlayerEventProducer

/// A `PlayerEventProducer` listens to notifications and observes events generated by an AVPlayer.
class PlayerEventProducer: NSObject, EventProducerP {
    
    enum PlayerEvent: EventP {
        
        case startedBuffering
        
        /// buffered enough data
        case readyToPlay
        
        case loadedMoreRange(earliest: CMTime, latest: CMTime)
        
        case loadedMetadata(metadata: [AVMetadataItem])
        
        /// The player has found audio item duration.
        case loadedDuration(duration: CMTime)
        
        /// The player progressedPlaying in its playing
        case progressedPlaying(time: CMTime)
        
        /// The player ended playing the current item because it went through the file or because of an error
        case endedPlaying(error: Error?)
        
        ///  The player got interrupted (phone call, Siri, ...)
        case interruptionBegan
        
        case interruptionEnded(shouldResume: Bool)
        
        case routeChanged
        
        /// audio session is messed up
        case sessionMessedUp
    }
    
    /// The player to produce events with.
    ///
    /// Note that setting it has the same result as calling `stopProducing`.
    var player: AVPlayer? {
        willSet {
            stopProducing()
        }
    }
    
    weak var eventListener: EventListenerP?
    
    /// The time observer for the player.
    private var timeObserver: Any?
    
    private var listening = false
    
    
    //MARK: -
    
    /// Starts listening to the player events.
    func startProducing() {
        guard let player = player, !listening else {
            return
        }
        
        //Observing notifications sent through `NSNotificationCenter`
        let center = NotificationCenter.default
        
        center.addObserver(self,
                           selector: .audioSessionInterrupted,
                           name: AVAudioSession.interruptionNotification,
                           object: nil)
        
        center.addObserver(self,
                           selector: .audioRouteChanged,
                           name: AVAudioSession.routeChangeNotification,
                           object: nil)
        
        center.addObserver(self,
                           selector: .audioSessionMessedUp,
                           name: AVAudioSession.mediaServicesWereLostNotification,
                           object: nil)
        
        center.addObserver(self,
                           selector: .audioSessionMessedUp,
                           name: AVAudioSession.mediaServicesWereResetNotification,
                           object: nil)
        
        center.addObserver(self,
                           selector: .itemDidEnd,
                           name: .AVPlayerItemDidPlayToEndTime,
                           object: player.currentItem)
        
        //Observing AVPlayer's property
        AVPlayer.ap_KVOProperties.forEach { keyPath in
            player.addObserver(self,
                               forKeyPath: keyPath,
                               options: .new,
                               context: nil)
        }
        
        //Observing timing event
        let interval = CMTimeMake(value: 1, timescale: 2)
        timeObserver = player.addPeriodicTimeObserver(forInterval: interval,
                                                      queue: .main) { [weak self] time in
            guard let slf = self else {
                return
            }
            let event = PlayerEvent.progressedPlaying(time: time)
            slf.eventListener?.onEvent(event, generetedBy: slf)
        }
        listening = true
    }
    
    /// Stops listening to the player events.
    func stopProducing() {
        guard let player = player, listening else {
            return
        }
        
        //Unobserving notifications sent through `NSNotificationCenter`
        let center = NotificationCenter.default
        center.removeObserver(self,
                              name: AVAudioSession.interruptionNotification,
                              object: nil)
        center.removeObserver(self,
                              name: AVAudioSession.routeChangeNotification,
                              object: nil)
        center.removeObserver(self,
                              name: AVAudioSession.mediaServicesWereLostNotification,
                              object: nil)
        center.removeObserver(self,
                              name: AVAudioSession.mediaServicesWereResetNotification,
                              object: nil)
        
        center.removeObserver(self, name: .AVPlayerItemDidPlayToEndTime, object: player.currentItem)
        
        //Unobserving AVPlayer's property
        AVPlayer.ap_KVOProperties.forEach { keyPath in
            player.removeObserver(self, forKeyPath: keyPath)
        }
        
        //Unobserving timing event
        if let timeObserver = timeObserver {
            player.removeTimeObserver(timeObserver)
        }
        timeObserver = nil
        listening = false
    }
    
    /// This message is sent to the receiver when the value at the specified key path relative to the given object has
    /// changed. The receiver must be registered as an observer for the specified `keyPath` and `object`.
    ///
    /// - Parameters:
    ///   - keyPath: The key path, relative to `object`, to the value that has changed.
    ///   - object: The source object of the key path `keyPath`.
    ///   - change: A dictionary that describes the changes that have been made to the value of the property at the key
    ///         path `keyPath` relative to `object`. Entries are described in Change Dictionary Keys.
    ///   - context: The value that was provided when the receiver was registered to receive key-value observation
    ///         notifications.
    override func observeValue(forKeyPath keyPath: String?,
                               of object: Any?,
                               change: [NSKeyValueChangeKey: Any]?,
                               context: UnsafeMutableRawPointer?) {
        
        guard let keyPath = keyPath,
            let p = object as? AVPlayer,
            let currentItem = p.currentItem else {
                return
        }
        
        let events: [PlayerEvent]
        if keyPath == "currentItem.duration" {
            
            let duration = currentItem.duration
            let event1 = PlayerEvent.loadedDuration(duration: duration)
            
            let metadata = currentItem.asset.commonMetadata
            let event2 = PlayerEvent.loadedMetadata(metadata: metadata)
            events = [event1, event2]
            
        } else if keyPath == "currentItem.playbackBufferEmpty", currentItem.isPlaybackBufferEmpty {
            
            events = [PlayerEvent.startedBuffering]
            
        } else if keyPath == "currentItem.playbackLikelyToKeepUp", currentItem.isPlaybackLikelyToKeepUp {
            
            events = [PlayerEvent.readyToPlay]
            
        } else if keyPath == "currentItem.status",
            currentItem.status == .failed {
            
            let event = PlayerEvent.endedPlaying(error: currentItem.error)
            events = [event]
            
        } else if keyPath == "status",
            p.status == .readyToPlay {
            
            events = [PlayerEvent.readyToPlay]
            
        } else if keyPath == "currentItem.loadedTimeRanges",
            let range = currentItem.loadedTimeRanges.last?.timeRangeValue {
            
            let event = PlayerEvent.loadedMoreRange(earliest: range.start,
                                                    latest: range.end)
            events = [event]
            
        } else if keyPath == "currentItem.timedMetadata",
            let metadata = currentItem.timedMetadata {
            
            let event = PlayerEvent.loadedMetadata(metadata: metadata)
            events = [event]
            
        } else {
            return
        }
        events.forEach {
            eventListener?.onEvent($0, generetedBy: self)
        }
    }
    
    /// Audio session got interrupted by the system (call, Siri, ...). If interruption begins, we should ensure the
    /// audio pauses and if it ends, we should restart playing if state was `.playing` before.
    ///
    /// - Parameter note: The notification information.
    @objc fileprivate func audioSessionGotInterrupted(note: NSNotification) {
        
        guard let userInfo = note.userInfo,
            let typeInt = userInfo[AVAudioSessionInterruptionTypeKey] as? UInt,
            let type = AVAudioSession.InterruptionType(rawValue: typeInt) else {
                return
        }
        
        let events: [PlayerEvent]
        if type == .began {
            events = [PlayerEvent.interruptionBegan]
            
        } else if let optionInt = userInfo[AVAudioSessionInterruptionOptionKey] as? UInt {
            
            let options = AVAudioSession.InterruptionOptions(rawValue: optionInt)
            let should = options.contains(.shouldResume)
            let event = PlayerEvent.interruptionEnded(shouldResume: should)
            events = [event]
        } else {
            return
        }
        events.forEach {
            eventListener?.onEvent($0, generetedBy: self)
        }
    }
    
    /// Audio session route changed (ex: earbuds plugged in/out). This can change the player state, so we just adapt it.
    ///
    /// - Parameter note: The notification information.
    @objc fileprivate func audioSessionRouteChanged(note: NSNotification) {
        eventListener?.onEvent(PlayerEvent.routeChanged, generetedBy: self)
    }
    
    /// Audio session got messed up (media services lost or reset). We gotta reactive the audio session and reset
    /// player.
    ///
    /// - Parameter note: The notification information.
    @objc fileprivate func audioSessionMessedUp(note: NSNotification) {
        eventListener?.onEvent(PlayerEvent.sessionMessedUp, generetedBy: self)
    }
    
    /// Playing item did end. We can play next or stop the player if queue is empty.
    ///
    /// - Parameter note: The notification information.
    @objc fileprivate func playerItemDidEnd(note: NSNotification) {
        eventListener?.onEvent(PlayerEvent.endedPlaying(error: nil), generetedBy: self)
    }
    
    deinit {
        stopProducing()
    }
}
