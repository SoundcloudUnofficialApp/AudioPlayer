//
//  QualityAdjEventProducer.swift
//  AudioPlayer
//
//  Created by Kevin DELANNOY on 11/03/16.
//  Copyright Â© 2016 Kevin Delannoy. All rights reserved.
//

import Foundation

private extension Selector {
    /// The selector to call when the timer ticks.
    static let timerTicked = #selector(QualityAdjEventProducer.timerTicked(_:))
}

/// A `QualityAdjEventProducer` generates `QualityAdjEvent`s when there should be a change of quality based on some information about interruptions.
class QualityAdjEventProducer: NSObject, EventProducerP {
    
    /// `QualityAdjEvent` is a list of event that can be generated by `QualityAdjEventProducer`.
    enum QualityAdjEvent: EventP {
        /// The quality should go down if possible
        case goDown
        /// The quality should go up if possible.
        case goUp
    }
    
    /// used to adjust quality
    private var timer: Timer?
    
    
    weak var eventListener: EventListenerP?
    
    
    private var listening = false
    
    /// It will be used to determine whether the quality should change.
    var interruptionCount = 0 {
        didSet {
            checkInterruptionCount()
        }
    }
    
    /// Delay within which the player wait for an interruption before upgrading the quality.
    ///  Default value is 10 minutes.
    var adjQualityInternal = TimeInterval(10 * 60) {
        didSet {
            guard let timer = timer,
                listening else {
                    return
            }
            //We don't want to reset state in here because we want to keep the interruption
            //count and we also have to change the timer fire date.
            let delta = adjQualityInternal - oldValue
            let newFireDate = timer.fireDate.addingTimeInterval(delta)
            let timeInterval = newFireDate.timeIntervalSinceNow
            
            timer.invalidate()
            
            if timeInterval < 1 {
                //In this case, the timer should have been fired based on the last
                //fire date and the new `adjQualityInternal`. So we fire now.
                timerTicked(timer)
                return
            }
            
            //Else the timer fire date needs to be adjusted.
            self.timer = Timer.scheduledTimer(
                timeInterval: timeInterval,
                target: self,
                selector: .timerTicked,
                userInfo: nil,
                repeats: false)
        }
    }
    
    /// Max number of interruption to have within the `adjustQualityTimeInterval` delay before
    /// downgrading the quality. Default value is 5.
    var adjustQualityAfterInterruptionCount = 5 {
        didSet {
            checkInterruptionCount()
        }
    }

    /// Starts listening to the player events.
    func startProducing() {
        guard !listening else {
            return
        }
        resetState()
        listening = true
    }
    
    /// Stops listening to the player events.
    func stopProducing() {
        guard listening else {
            return
        }
        
        timer?.invalidate()
        timer = nil
        listening = false
    }
    
    
    private func resetState() {
        interruptionCount = 0
        
        timer?.invalidate()
        timer = Timer.scheduledTimer(
            timeInterval: adjQualityInternal,
            target: self,
            selector: .timerTicked,
            userInfo: nil,
            repeats: false)
    }
    
    /// Checks that the interruption count is lower than `adjustQualityAfterInterruptionCount`. If it isn't, the
    /// function generates an event and reset its state.
    private func checkInterruptionCount() {
        
        guard interruptionCount >= adjustQualityAfterInterruptionCount,
            listening else {
                return
        }
        timer?.invalidate()
        eventListener?.onEvent(QualityAdjEvent.goDown, generetedBy: self)
        resetState()
    }
    
    /// The quality adjuster ticked.
    ///
    /// - Parameter _: The timer.
    @objc fileprivate func timerTicked(_: AnyObject) {
        guard interruptionCount == 0 else {
            resetState()
            return
        }
        eventListener?.onEvent(QualityAdjEvent.goUp, generetedBy: self)
    }
    
    deinit {
        stopProducing()
    }
}
